"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
exports.__esModule = true;
exports.defaultDclIgnore = exports.shaHashMaker = exports.downloadFile = exports.ensureCopyFile = exports.ensureWriteFile = exports.getSceneJson = exports.entityV3FromFolder = exports.copyDir = void 0;
var fs = require("fs");
var glob_1 = require("glob");
var path = require("path");
var http = require("http");
var https = require("https");
var crypto = require("crypto");
var ignore_1 = require("ignore");
// instead of using fs-extra, create a custom function to no need to rollup
function copyDir(src, dest) {
    return __awaiter(this, void 0, void 0, function () {
        var entries, _i, entries_1, entry, srcPath, destPath, _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, fs.promises.mkdir(dest, { recursive: true })];
                case 1:
                    _b.sent();
                    return [4 /*yield*/, fs.promises.readdir(src, { withFileTypes: true })];
                case 2:
                    entries = _b.sent();
                    _i = 0, entries_1 = entries;
                    _b.label = 3;
                case 3:
                    if (!(_i < entries_1.length)) return [3 /*break*/, 9];
                    entry = entries_1[_i];
                    srcPath = path.join(src, entry.name);
                    destPath = path.join(dest, entry.name);
                    if (!entry.isDirectory()) return [3 /*break*/, 5];
                    return [4 /*yield*/, copyDir(srcPath, destPath)];
                case 4:
                    _a = _b.sent();
                    return [3 /*break*/, 7];
                case 5: return [4 /*yield*/, fs.promises.copyFile(srcPath, destPath)];
                case 6:
                    _a = _b.sent();
                    _b.label = 7;
                case 7:
                    _a;
                    _b.label = 8;
                case 8:
                    _i++;
                    return [3 /*break*/, 3];
                case 9: return [2 /*return*/];
            }
        });
    });
}
exports.copyDir = copyDir;
function entityV3FromFolder(_a) {
    var folder = _a.folder, addOriginalPath = _a.addOriginalPath, ignorePattern = _a.ignorePattern, customHashMaker = _a.customHashMaker;
    var sceneJsonPath = path.resolve(folder, './scene.json');
    var defaultHashMaker = function (str) { return 'b64-' + Buffer.from(str).toString('base64'); };
    var hashMaker = customHashMaker ? customHashMaker : defaultHashMaker;
    if (fs.existsSync(sceneJsonPath)) {
        var sceneJson = JSON.parse(fs.readFileSync(sceneJsonPath).toString());
        var _b = sceneJson.scene, base = _b.base, parcels = _b.parcels;
        var pointers_1 = new Set();
        pointers_1.add(base);
        parcels.forEach(function ($) { return pointers_1.add($); });
        var allFiles = (0, glob_1.sync)('**/*', {
            cwd: folder,
            dot: false,
            absolute: true
        })
            .map(function (file) {
            try {
                if (!fs.statSync(file).isFile())
                    return;
            }
            catch (err) {
                return;
            }
            var _folder = folder.replace(/\\/gi, '/');
            var key = file.replace(_folder, '').replace(/^\/+/, '');
            return key;
        })
            .filter(function ($) { return !!$; });
        var ensureIgnorePattern = (ignorePattern && ignorePattern !== '') ? ignorePattern : (0, exports.defaultDclIgnore)();
        var ig = (0, ignore_1["default"])().add(ensureIgnorePattern);
        var filteredFiles = ig.filter(allFiles);
        var mappedFiles = filteredFiles
            .map(function (file) {
            try {
                if (!fs.statSync(file).isFile())
                    return;
            }
            catch (err) {
                return;
            }
            var _folder = folder.replace(/\\/gi, '/');
            var key = file.replace(_folder, '').replace(/^\/+/, '');
            return { file: key.toLowerCase(), original_path: addOriginalPath ? key : undefined, hash: hashMaker(key) };
        })
            .filter(function ($) { return !!$; });
        return {
            version: 'v3',
            type: 'scene',
            id: hashMaker(folder),
            pointers: Array.from(pointers_1),
            timestamp: Date.now(),
            metadata: sceneJson,
            content: mappedFiles
        };
    }
    return null;
}
exports.entityV3FromFolder = entityV3FromFolder;
function getSceneJson(_a) {
    var baseFolders = _a.baseFolders, pointers = _a.pointers, customHashMaker = _a.customHashMaker;
    var requestedPointers = new Set(pointers);
    var resultEntities = [];
    var allDeployments = baseFolders.map(function (folder) {
        var dclIgnorePath = path.resolve(folder, '.dclignore');
        var ignoreFileContent = '';
        if (fs.existsSync(dclIgnorePath)) {
            ignoreFileContent = fs.readFileSync(path.resolve(folder, '.dclignore'), 'utf-8');
        }
        return entityV3FromFolder({
            folder: folder,
            addOriginalPath: false,
            ignorePattern: ignoreFileContent,
            customHashMaker: customHashMaker
        });
    });
    var _loop_1 = function (pointer) {
        // get deployment by pointer
        var theDeployment = allDeployments.find(function ($) { return $ && $.pointers.includes(pointer); });
        if (theDeployment) {
            // remove all the required pointers from the requestedPointers set
            // to prevent sending duplicated entities
            theDeployment.pointers.forEach(function ($) { return requestedPointers["delete"]($); });
            // add the deployment to the results
            resultEntities.push(theDeployment);
        }
    };
    for (var _i = 0, _b = Array.from(requestedPointers); _i < _b.length; _i++) {
        var pointer = _b[_i];
        _loop_1(pointer);
    }
    return resultEntities;
}
exports.getSceneJson = getSceneJson;
function ensureWriteFile(filePath, data) {
    return __awaiter(this, void 0, void 0, function () {
        var directoryPath;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    directoryPath = path.dirname(filePath);
                    if (!!fs.existsSync(directoryPath)) return [3 /*break*/, 2];
                    return [4 /*yield*/, fs.promises.mkdir(directoryPath, { recursive: true })];
                case 1:
                    _a.sent();
                    _a.label = 2;
                case 2: return [4 /*yield*/, fs.promises.writeFile(filePath, data, 'utf-8')];
                case 3:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    });
}
exports.ensureWriteFile = ensureWriteFile;
function ensureCopyFile(fromFilePath, filePath) {
    return __awaiter(this, void 0, void 0, function () {
        var directoryPath;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    directoryPath = path.dirname(filePath);
                    if (!!fs.existsSync(directoryPath)) return [3 /*break*/, 2];
                    return [4 /*yield*/, fs.promises.mkdir(directoryPath, { recursive: true })];
                case 1:
                    _a.sent();
                    _a.label = 2;
                case 2: return [4 /*yield*/, fs.promises.copyFile(fromFilePath, filePath)];
                case 3:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    });
}
exports.ensureCopyFile = ensureCopyFile;
var downloadFile = function (url, path) { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        return [2 /*return*/, new Promise(function (resolve, reject) {
                var file = fs.createWriteStream(path);
                var schema = http;
                if (url.toLowerCase().startsWith('https:')) {
                    schema = https;
                }
                schema
                    .get(url, function (response) {
                    response.pipe(file);
                    file.on('finish', function () {
                        file.close();
                        resolve(true);
                    });
                })
                    .on('error', function (err) {
                    fs.unlinkSync(path);
                    reject(err);
                });
            })];
    });
}); };
exports.downloadFile = downloadFile;
var shaHashMaker = function (str) { return crypto.createHash('sha1').update(str).digest('hex'); };
exports.shaHashMaker = shaHashMaker;
var defaultDclIgnore = function () {
    return [
        '.*',
        'package.json',
        'package-lock.json',
        'yarn-lock.json',
        'build.json',
        'export',
        'tsconfig.json',
        'tslint.json',
        'node_modules',
        '*.ts',
        '*.tsx',
        'Dockerfile',
        'dist',
        'README.md',
        '*.blend',
        '*.fbx',
        '*.zip',
        '*.rar'
    ].join('\n');
};
exports.defaultDclIgnore = defaultDclIgnore;
